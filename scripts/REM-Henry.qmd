---
title: "REM-Henry"
author: "Henry Li"
format: html
editor: visual
---

## Readme

input: ONE sheet of labeled data (in 'perfected' format), from cleaned-data-as-input folder

output: NULL

purpose:

1.  prepares ONE sheet of data ready for REM analysis;

2.  performs analysis with relevent

# Pre-processing

```{r setup, include = FALSE}
library(here)
library(dplyr) 
library(tidyr)
library(purrr)
```

## read the cleaned data (in 'perfected' format)

```{r}
testdata <- read.csv(here("raw-data", "05_20_2021_vero #5_round 3_otter.ai_made_perfect.csv"))
head(testdata)
```

## 1. Remove NA entries

```{r}
testdata <- testdata %>%
  filter(!is.na(user) & !is.na(to))
```

## 2. List of all participants (excluding Vero)

```{r}
participants <- unique(testdata$user)
participants <- participants[!participants %in% c("Vero", "all")]
```

## 3. List of participants + Vero

```{r}
participants_with_vero <- if("Vero" %in% participants) {
  c(participants)
} else {
  c("Vero", participants)
}
```

## 4 Expand "to" column and handle different cases

```{r}
testdata <- testdata %>%
  separate_longer_delim(c(to, task_pos, task_conf, rel_pos, rel_conf, X3rdVero), delim = ",")
```

## 5. Remove "Participant " from user column

```{r}
testdata$user <- gsub("Participant ", "", testdata$user)
```

## 6. Process time and add 0.1s increment for simultaneous events

1.  simultaneously addressing more than one recipients

2.  two events happening within one second frame (necessary for well-ordering) (Butts and Marcum 2017:11)

***Let us know if you have better solutions!***

Since `n()` is the number of rows in each group, and `runif` generates a unique random number for each row, the adjusted `time` values will be distinct unless the random number generator happens to produce the same value multiple times, which is highly unlikely given the continuous nature of `runif`. Inclusive of 0.

robustness check: varying seeds only slightly change coefficients. Seems to not change the significance level.

```{r}
set.seed(123)
testdata <- testdata %>%
  group_by(time) %>%
  mutate(time = time + runif(n(), min = 0, max = 0.1)) %>%
  ungroup() %>%
  arrange(time)
```

## 7. Handle "all" case and ensure consistent formatting

```{r}
testdata <- testdata %>%
  mutate(
    to = if_else(to == "all", "1", to),  # Replace "all" with "1"
    to = as.numeric(to),                 # Convert "to" to numeric
    time = time - min(time)              # Adjust "time" column to 0
  )

map_ids_to_integers <- function(df, from_col, to_col) {
  # Convert specified columns to character type and gather unique IDs
  unique_ids <- df %>%
    select(all_of(c(from_col, to_col))) %>%
    mutate(across(everything(), as.character)) %>%
    unlist() %>%
    unique()
  
  # Create a mapping of unique IDs to integers
  id_mapping <- tibble(ID = unique_ids, Integer = seq_along(unique_ids))
  
  # Apply the mapping to the specified columns
  df <- df %>%
    mutate(across(all_of(c(from_col, to_col)), ~ id_mapping$Integer[match(.x, id_mapping$ID)]))

  # Return the adjusted df and mapping table
  return(list(adjusted_df = df, mapping_table = id_mapping))
}

# Example usage with test data
test_attribute <- tibble(team_id = testdata$Team_id[1], Vero_type = testdata$condition[1])
test_data_run <- tibble(time = testdata$time, from = testdata$user, to = testdata$to)
data_prepared <- map_ids_to_integers(test_data_run, "from", "to")
```

```{r eval=FALSE, include=FALSE}
# ###*** map Participant IDs into 1,2,3,4,...
# map_ids_to_integers <- function(df, from_col, to_col) {
#   # Convert specified columns to character type
#   df[[from_col]] <- as.character(df[[from_col]])
#   df[[to_col]] <- as.character(df[[to_col]])
#   
#   # Extract unique IDs from both specified columns
#   unique_ids <- unique(c(df[[from_col]], df[[to_col]]))
#   
#   # Create a mapping of unique IDs to integers
#   id_mapping <- setNames(1:length(unique_ids), unique_ids)
#   
#   # Apply the mapping to the specified columns
#   df[[from_col]] <- id_mapping[df[[from_col]]]
#   df[[to_col]] <- id_mapping[df[[to_col]]]
#   
#   # Create and print the mapping table
#   mapping_table <- data.frame(ID = names(id_mapping), Integer = id_mapping)
#   print(mapping_table)
#   
#   # Return the adjusted dataframe
#   return(list(adjusted_df = df, mapping_table = mapping_table))
# }
# 
# test_attribute <- tibble(team_id = testdata$Team_id[1], Vero_type = testdata$condition[1]) 
# test_data_run <-data.frame(from=testdata$user, to=testdata$to, time=testdata$time)
# data_prepared <- map_ids_to_integers(test_data_run, "from", "to")
```

## REM

```{r}
edgelist_df = data_prepared$adjusted_df
mapping_table = data_prepared$mapping_table
model1 <- rem.dyad(
  edgelist = edgelist_df ,
  effects = c("RSndSnd", "RRecSnd", "CovSnd","PSAB-BA","PSAB-BY"), 
  n = max(c(edgelist_df$from,edgelist_df$to)),
  covar = list(CovSnd = 1),
  ordinal = FALSE, 
  hessian = TRUE)

# Remember CovSnd.1 is the model intercept
summary(model1)
```
